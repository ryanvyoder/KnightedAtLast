<!DOCTYPE HTML>
<html>
  <head>
    <meta charset = "utf-8"/>
    <title>Knighted At Last</title>
    <style>
      *{padding: 0; margin: 0}
      canvas {background: #eee; display: block; margin: 0 auto;}
    </style>
  </head>
  <body>
    <!-- render the game here -->
    <canvas id = "theCanvas" width = "100%" height = "100%"></canvas>
    <!-- Code for the game here -->
    <script>
    /*
      NOTES:
      - levels: object? they are initiated, given bool true/false if active?
          - each level creates GameObjects that align to the objects within their layout. perhaps have a global
            GameObject array that is added to/removed from by the levels individually. That way when a new level is active,
            it changes the array as it needs it. (array is more for hitboxes and interactions, but perhaps draw() will also call draw from every object in the array)
     */
    'use strict';
      var canvas = document.getElementById("theCanvas");  // the canvas object we paint on
      // !!!!!!!! Update this in the future such that if the user resizes the window, the canvas does as well.
      canvas.width = window.innerWidth;                   // set the canvas width to that of the display
      canvas.height = window.innerHeight;                 // set the canvas height to that of the display
      var context = canvas.getContext("2d");              // the actual tool we use to paint on the canvas
      var leftPressed = false, rightPressed = false, upPressed = false, downPressed = false;
      var activeObjects = [];
      var enemies = [];
      var hitboxView = 0;
    </script>

    <script src = "Rectangle.js"></script>
    <script src = "Sprite.js"></script>
    <script src="GameObject.js"></script>
    <script src="Player.js"></script>
    <script src = "Enemy.js"></script>

    <script>
      // Handling keypresses (controlling our character)
      document.addEventListener("keydown", keyDownHandler, false);
      document.addEventListener("keyup", keyUpHandler, false);

      var knight = new Player(100, canvas.height-250, 220, 400);
      var enemy1 = new Enemy(700, knight.getY() + (knight.getHeight() - 50), 50, 50, "hop");
      var enemy2 = new Enemy(700, knight.getY() + (knight.getHeight() - 50), 50, 50, "slide");
      activeObjects.push(knight);
      activeObjects.push(enemy1);
      activeObjects.push(enemy2);
      enemies.push(enemy1);
      enemies.push(enemy2);
      var audio = new Audio('placeholder.wav');
      audio.loop = true;
      audio.play();
      var player = knight;

      /*
        keyDownHandler()
        Called every update if a key has been pressed down
       */
      function keyDownHandler(e){
        if(e.keyCode == 37){ // Left arrow key
          leftPressed = true;
        }
        else if(e.keyCode == 38){ // Up arrow key
          upPressed = true;
        }
        else if(e.keyCode == 39){ // Right arrow key
          rightPressed = true;
        }
        else if(e.keyCode == 40){ // Down arrow key
          downPressed = true;
        }
      }

      /*
        keyUpHandler()
        Called every update if a key is now not pressed down
       */
      function keyUpHandler(e){
        if(e.keyCode == 37){ // Left arrow key
          leftPressed = false;
        }
        else if(e.keyCode == 38){ // Up arrow key
          upPressed = false;
        }
        else if(e.keyCode == 39){ // Right arrow key
          rightPressed = false;
        }
        else if(e.keyCode == 40){ // Down arrow key
          downPressed = false;
        }
      }

      /*
        draw()
        Called every update. Clears the canvas and then redraws the next frame.
       */
      function draw(){
        // Drawing code
        clearCanvas();

        // Kill an enemy if it touches you

        // NOTE:
        // VERY weird thing here. When I use a for loop, it does NOT always execute the full loop.
        // Sometimes it only executes the first iteration and then moves on! I'm not sure if this is something
        // with setInterval where perhaps it estimates how much time it has and skips if it has to, but
        // it forced me to use this little while loop instead. Interested to know what's going on here.

        //for(index = 0; index < enemies.length; index++){
        cnt = 0;
        while(cnt < enemies.length){
          if(player.collides(enemies[cnt])){
            enemies[cnt].kill();
          }
          cnt++;
        }


        for(index = 0; index < enemies.length; index++){
          console.log("Checking alive enmy: " + index);
          if(!enemies[index].isAlive()){
            theIndex = 0;
            for(q = 0; q < activeObjects.length; q++){
              if(activeObjects[q] == enemies[index]){
                theIndex = q;
                break;
              }
            }
            //theIndex = activeObjects.findIndex(enemies[index]);
            activeObjects.splice(theIndex, 1);
            enemies.splice(index, 1);
          }
        }

        for(index = 0; index < activeObjects.length; index++){
          activeObjects[index].update();
          activeObjects[index].draw();
        }
      }
      setInterval(draw, 10); //function will be called every <second param> milliseconds

      /*
        clearCanvas()
        Clears the context's canvas
       */
      function clearCanvas(){
        context.clearRect(0, 0, canvas.width, canvas.height);
      }
    </script>

  </body>
</html>
